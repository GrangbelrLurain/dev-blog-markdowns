---
createdAt: 2024-10-18
---

# Javascript 엔진이란?
자바스크립트 엔진은 자바스크립트 코드를 실행하는 인터프리터입니다.
(인터프리터 방식으로 컴파일 과정이 필요 없습니다.)
# 브라우저별 자바스크립트 엔진
## Rhino
Mozilla에서 운영하는 오픈 소스 엔진으로, Java로 개발되었습니다.
## SpiderMonkey
최초의 Javascript 엔진으로, 파이어폭스를 지원하고 있습니다.
과거 넷스케이프 네비게이터를 지원했습니다.
## V8
구글이 개발한 오픈 소스 엔진으로, 구글 크롬을 지원하고 있습니다.
## JavascriptCore
애플이 개발한 엔진으로, 사파리와 React Native App을 지원하고 있습니다.
처음엔 Webkit 프레임워크를 위해 개발되었습니다.
## Chakra
마이크로소프트가 개발한 엔진으로, Edge 브라우저를 지원하고 있습니다.

# 자바스크립트 엔진의 구조
가장 유명한 V8 엔진을 예시로 자바스크립트 엔진의 구조를 살펴보겠습니다.
자바스크립트 엔진은 크게 Heap Memory와 Call Stack으로 구성되어 있습니다.

![[Pasted image 20241018223703.png]]

하지만 브라우저에서 사용하는 모든 기능을 자바스크립트 엔진에서 제공해주지는 않습니다.
`DOM, AJAX, setTimeout` 등의 **Web API**, Web API 호출을 통제하는 **Event Queue**, **Event Loop** 등이 존재합니다.

# Heap Memory

> Heap Memory
> : 동적 메모리 할당에 사용되는 자료구조

V8 엔진은 힙 메모리에 객체 또는 동적 데이터를 저장합니다.
여기에 저장되는 메모리는 V8 엔진 내부에서 가장 큰 공간을 차지하고 있습니다.
가비지 컬렉션 또한 여기서 발생합니다.

## 메모리 관리

Javascript는 고수준 언어로서 자동으로 메모리를 관리합니다.
이를 가비지 컬렉션이라고 합니다.

가비지 컬렉션에는 여러가지 알고리즘이 있습니다.
## 메모리 관리 알고리즘

> Reference-counting 알고리즘
> : 다른 어떤 객체도 참조하지 않는 객체 === 필요 없는 객체로 간주합니다.

> Mark-and-sweep 알고리즘
> : root 객체에서 참조하는 객체가 참조하는 객체 등을 찾아 모든 도달할 수 있는 객체와 도달할 수 없는 객체를 구분하여 수집합니다.

하지만 이 두 가지 알고리즘도 수동으로 메모리를 관리할 수 없다는 문제점이 있습니다.
이로 인해 자바스크립트 엔진은 수동 메모리 관리 기능을 제공하지만, 대부분의 브라우저 및 웹페이지에서는 제공되지 않습니다. (node.js에서는 제공합니다.)

## WeakMaps와 WeakSets

가비지 컬렉션은 자동으로 메모리를 관리합니다.
그러면 수동으로 메모리를 관리하고 싶을 때는 어떻게 해야 할까요?
Javascript가 가비지 컬렉션 API를 직접 노출하지는 않지만, 간접적으로 메모리 관리에 쓸 수 있는 데이터 구조를 제공합니다.
바로 WeakMaps와 WeakSets를 통해 수동으로 메모리를 관리할 수 있습니다.

해당 내용은 이 문서의 내용을 넘어가므로 자세히 다루지는 않겠습니다.

# Call Stack

> Call Stack
> : 프로그램 상에서 현재 어디에 있는지 기록하는 자료구조

Javascript는 싱글 스레드 기반이므로, 한 번에 하나의 작업만 진행됩니다.
따라서 단일 콜 스택에서 한 번에 한 작업(Task)만 처리합니다.

## Call Stack의 실행 순서

![[Pasted image 20241018223939.png]]

엔진이 왼쪽의 one 함수를 호출하면, Call Stack에는 one - two - three 순서대로 Call Stack이 쌓이게 됩니다. 그리고 호출된 순서의 역순으로 함수가 실행된 결과를 내보내게 됩니다.

## Call Stack의 예외 처리
만약 `function three`에서 예외가 발생하게 된다면 어떻게 될까요?
```node
Uncaught Error: index.js:10
	at three (index.js:8)
	at two (index.js:5)
	at one (index.js:2)
	at index.js:13
```
해당 순서대로 에러가 발생할 것입니다.

## Stack Overflow
콜 스택에는 제한 크기가 있습니다. 콜 스택의 제한 크기를 초과했을 때 스택 오버플로우가 발생합니다. 예를 들어 아래와 같은 재귀함수를 호출하면 어떻게 될까요?
```typescript
const recursiveFunction = () => {
	...
	recursiveFunction()
}

recursiveFunction()
```

recursiveFunction은 스스로를 계속 호출하게 되고, 어느 순간 콜 스택의 최대 크기를 초과하게 됩니다. 그러면 브라우저는 `Maximum call stack size exceeded`와 같은 오류를 발생시키고 함수를 종료시키게 됩니다.

## 비동기 처리
앞서 자바스크립트 엔진이 단일 스레드라고 말씀드렸습니다. 그렇다면 실행하는데 아주 오래 걸리는 함수를 단일 스레드에서 처리하게 되면 어떻게 될까요? 자바스크립트 엔진이 해당 함수를 처리하는 동안 다른 동작은 할 수 없게 될 것입니다.

이러한 동작을 처리하는 방법 중 하나로 비동기 처리가 있습니다. 비동기 처리란, 현재 실행 중인 Call Stack이 종료되기 전에 다음 라인의 코드를 실행하는 것을 의미합니다. 일반적으로 비동기 작업은`Promise`, `setTimeout`등의 비동기 API를 호출하여 사용할 수 있습니다. 비동기 작업을 기다리는 동안 메인 스레드는 다른 작업을 처리할 수 있습니다.

> 비동기로 동작하는 핵심 요소는 자바스크립트가 아닌 브라우저라는 소프트웨어가 가지고 있다고 볼 수 있습니다. Node.js에서는 libuv 내장 라이브러리가 처리합니다.

![[Pasted image 20241018231605.png]]

### 콜백 큐와 이벤트 루프

비동기 Web API가 실행되면 메인 스레드 외부에서 실행된 후 callback 함수를 Callback Queue에 대기시키게 됩니다. 이벤트 루프는 Call Stack과 Callback Queue를 지켜보고 있다가 Call Stack이 비게 되면 Callback Queue에 있는 callback 함수를 실행시키게 됩니다.